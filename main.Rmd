---
title: 'Conics'
author: 'fnaufel'
email: 'https://fnaufel.github.io/'
date: '   (v. `r format(Sys.Date(), "%d/%m/%Y")`)'
lang: 'en'

output: 
  # To install these output formats, run
  #   install.packages("devtools")
  #   devtools::install_github("fnaufel/fnaufelRmd")
  fnaufelRmd::html_report:
    []
---

```{r setup, include=FALSE}
# The next command configures MANY things and loads quite a few packages.
# 
# If you want to see what's being done, execute 
# 
#   cat(
#     system.file(
#       "rmarkdown/resources/R/_common_report.R", 
#       package = "fnaufelRmd"
#     )
#   )
# 
# to find out the location of the file. Then open the file.
# 
# If you want to change the configuration, copy the file, edit it, and
# source it instead of the package file. 
# 
# Or simply write your commands here in this code chunk.

source(
  system.file(
    "rmarkdown/resources/R/_common_report.R",
    package = "fnaufelRmd"
  )
)

library(conicas)
library(reticulate)
library(sympyglue)

sympy = import('sympy')
py_run_string('from sympy import *')
py_run_string('init_printing(use_latex=True)')
py_run_string('from pprint import pp')
py_run_string('x, y = symbols(\'x y\', real=True)')
```


# Complete the square

```{python}
def complsq(expr, var):
  
  # expr is of the form ax^2 + bx + c, and var == x
  
  error_msg = '''
  Expression must be of the form ax^2 + bx + c.
  The input was ''' + latex(expr)
  
  # var may be any symbol, but let's call it x here
  x = var
  
  # Used to match the coefficients
  a, b, c = [ \
    Wild(w, exclude=[x, y]) for w in 'abc' \
  ]
  
  # Match
  m = expr.match(a*x**2 + b*x + c)
  
  # No match: bad expression
  if m is None:
    raise ValueError(error_msg)
  
  # Get coefficients
  A, B, C = [w.xreplace(m) for w in [a, b, c]]
  
  # Expression must be of degree 2
  if A == 0:
    raise ValueError(error_msg)
  
  # Will return A (x + B/2A)^2 + (4AC - B^2)/4A
  second = sympify(B) / (2*A)
  third = sympify(4*A*C - B**2) / (4*A)
  
  return A * (var + second)**2 + third
```


## Test complete square

```{python}
A, B, C = symbols('A B C', real=True)
complsq(A*x**2 + B*x + C, x)
```

```{python error=TRUE}
complsq(x**4 + 2*x, x)
```

```{r}
eg <- function(e) {
  
  cmd <- paste0('e = ', rlang::expr_text(rlang::enexpr(e)))
  cmd <- gsub('^', '**', cmd, fixed = TRUE)
  py_run_string(cmd)
  
  m('$$\\displaystyle {{e}} \\quad=\\quad {{complsq(e, x)}}$$')
}
```

```{r}
eg(x**2 + 2*x)
```

```{r}
eg(x**2 + 2*x + 1)
```

```{r}
eg(x**2 - 2*x)
```

```{r}
eg(4*x**2 + 2*x)
```

```{r}
eg(4*x**2 - 2*x)
```

```{r}
eg(-4*x**2 + 2*x)
```

```{r}
eg(-4*x**2 - 2*x)
```

```{r}
eg(4*x**2 + 2*x + 10)
```


# Classify


## Analysis


### A nondegenerate parabola with $x^2$

```{python}
A, B, C, D, E, F = symbols('A B C D E F', real=True)
C = 0
A*x**2 + C*y**2 + D*x + E*y + F
```


### A degenerate parabola (only $x$ terms):

```{python}
C = E = 0

eqx = A*x**2 + D*x
a, b, c = [Wild(w, exclude=[x, y]) for w in 'abc']
eqx = complsq(eqx, x)  
a, b, c = [Wild(w, exclude=[x, y]) for w in 'abc']
m = eqx.match(a * (x + b)**2 + c)
neweq = Eq(eqx.xreplace(m), -F)
neweq
```

```{python}
a, b, c = [Wild(w) for w in 'abc']
m = neweq.lhs.match(a*b - c)
neweq = Eq(b, (c - F)/a).xreplace(m)
neweq
```

```{python}
simplify(neweq.rhs)
```

Here we can analyze the numerator of the rhs to see if any $x$ satisfies this equality:

$$
\begin{cases}
  \displaystyle
  D^2 - 4AF < 0: &\text{empty set} \\
  D^2 - 4AF = 0: &\text{one line: } & x = -D/2A \\
  D^2 - 4AF > 0: &\text{two lines: } & x = \frac{-D \pm \sqrt{D^2 - 4AF}}{2A} 
\end{cases}
$$


### A nondegenerate parabola with $y^2$

```{python}
A, B, C, D, E, F = symbols('A B C D E F', real=True)
A = 0
A*x**2 + C*y**2 + D*x + E*y + F
```


### A degenerate parabola (only $y$ terms):

```{python}
A = D = 0

eqy = C*y**2 + E*y
a, b, c = [Wild(w, exclude=[x, y]) for w in 'abc']
eqy = complsq(eqy, y)  
m = eqy.match(a * (y + b)**2 + c)
neweq = Eq(eqy.xreplace(m), -F)
neweq
```

```{python}
a, b, c = [Wild(w) for w in 'abc']
m = neweq.lhs.match(a*b - c)
neweq = Eq(b, (c - F)/a).xreplace(m)
neweq
```

```{python}
simplify(neweq.rhs)
```

Here we can analyze the numerator of the rhs to see if any $y$ satisfies this equality:

$$
\begin{cases}
  \displaystyle
  E^2 - 4CF < 0: &\text{empty set} \\
  E^2 - 4CF = 0: &\text{one line: } & y = -E/2C \\
  E^2 - 4CF > 0: &\text{two lines: } & y = \frac{-E \pm \sqrt{E^2 - 4CF}}{2C} 
\end{cases}
$$


### Combining both cases

$$
\begin{cases}
  \displaystyle
  D^2 + E^2 - 4F(A + C) < 0: &\text{empty set} 
  \\
  D^2 + E^2 - 4F(A + C) = 0: &\text{one line: } 
  & x = -D/2A &\text{or}\quad y = -E/2C 
  \\
  D^2 + E^2 - 4F(A + C) > 0: &\text{two lines: } 
  & x = \frac{-D \pm \sqrt{D^2 - 4AF}}{2A} 
  &\text{or}\quad y = \frac{-E \pm \sqrt{E^2 - 4CF}}{2C} 
\end{cases}
$$


## Algorithm: classify 

From https://en.wikipedia.org/wiki/Degenerate_conic, considering the above analysis.

```{python}
def classify(eq):
  
  error_msg = '''
  Equation must be of the form Ax^2 + Cy^2 + Dx + Ey + F.
  The input was ''' + latex(eq)
  
  # Used to match the coefficients of the equation
  a, b, c, d, e, f = [ \
    Wild(w, exclude=[x, y]) for w in 'abcdef' \
  ]
  
  # Match
  m = eq.match(a*x**2 + b*x*y + c*y**2 + d*x + e*y + f)
  
  # No match: bad equation
  if m is None:
    raise ValueError(error_msg)
  
  # Get coefficients
  A, B, C, D, E, F = [w.xreplace(m) for w in [a, b, c, d, e, f]]
  
  # Must be degree 2 in at least one of the vars
  # No rotated conics for now
  if B != 0 or (A == 0 and C == 0):
    raise ValueError(error_msg)
  
  # Collect everything in a dict
  retval = { \
    'eq_general': Eq(eq, 0), \
    'A': A, \
    'B': B, \
    'C': C, \
    'D': D, \
    'E': E, \
    'F': F \
  }
  
  # Discriminants
  # Non-homogeneous form
  M = Matrix([[A, B/2], [B/2, C]])
  detM = M.det()
  
  # Homogeneous form
  Q = Matrix([[A, B/2, D/2], [B/2, C, E/2], [D/2, E/2, F]])
  detQ = Q.det()
  
  # Degenerate?
  is_degenerate = detQ == 0
  degenerate_form = ''
  
  # Type
  if detM > 0:
    # Ellipse or circle
    # Must check if empty set
    temp = A * (E**2 / (4*C) + D**2 / (4*A) - F)
    if temp < 0:
      conic_type = 'ellipse'
      is_degenerate = True
      degenerate_form = 'empty set'
    else:
      if A == C:
        conic_type = 'circle'
      else:
        conic_type = 'ellipse'
  elif detM == 0:
    conic_type = 'parabola'
  else:
    conic_type = 'hyperbola'
    
  # Degenerate form (but not empty-set ellipse, which has already been
  # identified above)
  if is_degenerate and degenerate_form == '':
    
    if conic_type == 'hyperbola':
      degenerate_form = 'intersecting lines'
      
    elif conic_type == 'parabola':
      temp = D**2 + E**2 - 4 * F * (A + C)
      if temp < 0:
        degenerate_form = 'empty set'
      elif temp == 0:
        degenerate_form = 'coincident lines'
      else: # temp > 0
        degenerate_form = 'parallel lines'
        
    elif detM > 0:
      conic_type = 'ellipse'
      degenerate_form = 'point'
      
  # Save info in dict
  retval['conic_type'] = conic_type
  retval['is_degenerate'] = is_degenerate
  retval['degenerate_form'] = degenerate_form
  
  return retval
```

This should be a parabola:

```{python}
parab = y + x**2
parab

pp(classify(parab))
```

This should be parallel lines:

```{python}
parab = y**2 - 4*y + 1
parab

pp(classify(parab))
```

This should be one line:

```{python}
parab = y**2 - 4*y + 4
parab

pp(classify(parab))
```

This should be the empty set:

```{python}
parab = y**2 - 4*y + 5
parab

pp(classify(parab))
```



## Tests for classify

```{python}
eq = x**2 + 2*x + y**2 + 4*y - 4
pp(classify(eq))
```

```{python error=TRUE}
eq = x + y
pp(classify(eq))
```

```{python}
eq = x**2 + x + 1
pp(classify(eq))
```

```{python error=TRUE}
eq = x * y
classify(eq)
```

```{python error=TRUE}
eq = x**2 + x*y + y**2 + x + y + 1
classify(eq)
```

```{r echo=FALSE, eval=FALSE}
df <- conicas::gerar_conicas_df()

n <- 80
tipos <- c(
  elipse = ceiling(n/8), 
  hipérbole = ceiling(n/8),
  parábola = ceiling(n/8),
  paralelas = ceiling(n/8), 
  concorrentes = ceiling(n/8),
  ponto = ceiling(n/8),
  reta = ceiling(n/8),
  vazio = ceiling(n/8)
)

eqs <- df %>% 
  filtrar_conicas(n, tipos) %>% 
  select(tipo, eq) %>% 
  mutate(
    eq = gsub('^', '**', eq, fixed = TRUE)
  ) %>% 
  mutate(
    eq = gsub(
      '([0-9])([xy])',
      '\\1*\\2',
      eq,
      perl = TRUE
    )
  )

eqs %>% 
  pull(eq) %>% 
  substr(1, nchar(.) - 4) %>% 
  paste0(
    '  ', ., ', \\\n',
    collapse = ''
  ) %>% 
  cat()
```

```{python}
eqs = [ \
  -5*x**2-3*y**2-4*x-2*y+4, \
  4*x**2+y**2+4*x+3*y+2, \
  -5*x**2-y**2-2*x+5*y+2, \
  2*x**2+3*y**2+5*x+3, \
  x**2+5*y**2+4*x-4*y+1, \
  5*x**2+4*y**2-x-3*y-2, \
  4*x**2+2*y**2-x+3*y-3, \
  x**2+5*y**2+4*x-5*y-1, \
  -4*x**2-2*y**2-4*x+5*y+5, \
  -4*x**2-5*y**2-2*x+3*y+1, \
  2*x**2-2*y**2-4*x-4*y-2, \
  -3*x**2+y**2-4*x+5*y-3, \
  x**2-2*y**2-4*x+y+2, \
  -3*x**2+4*y**2+1, \
  -4*x**2+3*y**2+2*x+1, \
  -5*x**2+y**2+2*x-4*y+4, \
  2*x**2-5*y**2-5*x+y-2, \
  -3*x**2+y**2+4*x-4*y-1, \
  x**2-y**2-x+2*y-2, \
  3*x**2-y**2+x-3*y-5, \
  5*x**2-x-4*y+2, \
  x**2-5*x+5*y+1, \
  x**2-x-y-3, \
  3*y**2+4*x+4*y+4, \
  2*x**2+4*x-3*y-3, \
  -2*x**2-3*x-y+1, \
  2*y**2-5*x, \
  -2*x**2-2*x-4*y, \
  -5*x**2-5*x-4*y+5, \
  -3*y**2+2*x+4, \
  3*x**2+4*x+1, \
  4*y**2+2*y-4, \
  -4*x**2+x, \
  x**2-2, \
  4*y**2-y-3, \
  -3*x**2-5*x+1, \
  -x**2-2*x+3, \
  -5*y**2+3*y, \
  -4*y**2+y+5, \
  4*x**2-5*x+1, \
  -x**2+3*y**2+4*x-4, \
  5*x**2-5*y**2+4*x-4*y, \
  -4*x**2+y**2+4*x-1, \
  x**2-4*y**2-2*x+1, \
  -x**2+y**2+x+3*y+2, \
  -x**2+4*y**2+3*x+2*y-2, \
  -3*x**2+3*y**2+5*x+y-2, \
  4*x**2-5*y**2+2*x-5*y-1, \
  -x**2+5*y**2-3*x-5*y-1, \
  4*x**2-4*y**2+4*y-1, \
  -5*x**2-5*y**2-4*x+2*y-1, \
  2*x**2+y**2-4*x+2, \
  -2*x**2-4*y**2-4*y-1, \
  -x**2-4*y**2+4*x-4*y-5, \
  4*x**2+y**2+2*y+1, \
  -x**2-2*y**2+2*x-1, \
  5*x**2+y**2+4*y+4, \
  -4*x**2-2*y**2, \
  -5*x**2-5*y**2-2*x-4*y-1, \
  -3*x**2-y**2-3*x+3*y-3, \
  -5*y**2+4*y+4, \
  3*x**2, \
  -3*y**2+2*y+1, \
  -2*y**2+2*y+1, \
  -x**2+2*x+1, \
  -x**2-2*x+1, \
  -3*x**2+4*x+4, \
  -5*y**2+2*y+1, \
  x**2, \
  -5*y**2-2*y+1, \
  4*x**2+5*y**2+2*x+y+3, \
  -5*x**2-4*y**2+5*x-y-2, \
  -4*x**2-4*y**2+x+4*y-2, \
  4*x**2+4*y**2-5*x-y+5, \
  -5*x**2-3*y**2+4*x-4*y-5, \
  -5*x**2-4*y**2+2*x-y-5, \
  -2*x**2-2*y**2+2*x-5*y-4, \
  5*x**2+3*y**2-x+5*y+3, \
  5*y**2-4*y+2, \
  5*x**2+4*y**2-4*x-5*y+4 \
]
```

```{python}
eq_list = [classify(eq) for eq in eqs]
```

```{r}
m(
  '{{ [ e[\'eq_general\'] for e in eq_list ] }} & ',
  '\\text{ {{s:[ e[\'conic_type\'] for e in eq_list ] }} } & ',
  '{{ [ e[\'is_degenerate\'] for e in eq_list ] }} & ',
  '\\text{ {{s:[ e[\'degenerate_form\'] for e in eq_list ] }} } \\\\ \n',
  before = '\\begin{array}{rlll} & \\text{Conic} & \\text{Degenerate?} & \\\\ \\hline \n',
  after = '\\hline \\end{array}'
)
```

To paste into Geogebra:

Equations:

```{r}
m(
  '{{r: [ e[\'eq_general\'] for e in eq_list ]}}',
  before = '{',
  after = '}',
  sep_middle = ', ',
  sep_blocks = ' ',
  use_cat = TRUE
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Names:

```{r}
m(
  '"{{s: [ e[\'conic_type\'] for e in eq_list ]}}, ',
  '{{s: [ e[\'degenerate_form\'] for e in eq_list ]}}"',
  before = '{',
  after = '}',
  sep_middle = ', ',
  sep_blocks = ' ',
  use_cat = TRUE
) %>% cat()
```


## BUGS (fixed)

* $4x^2 + 5y^2 + 2x + y + 3 = 0$ is the empty set, but is being classified as an ellipse.

* $-5x^2 - 4y^2 + 5x - y - 2 = 0$ is the empty set, but is being classified as an ellipse.

* $-4x^2 - 4y^2 + x + 4y - 2 = 0$ is the empty set, but is being classified as a circle.

* $4x^2 + 4y^2 - 5x - y + 5 = 0$ is the empty set, but is being classified as a circle.

* $-5x^2 - 3y^2 + 4x - 4y - 5 = 0$ is the empty set, but is being classified as an ellipse.

* $-5x^2 - 4y^2 + 2x - y - 5 = 0$ is the empty set, but is being classified as an ellipse.

* $-2x^2 - 2y^2 + 2x - 5y - 4 = 0$ is the empty set, but is being classified as a circle.

* $5x^2 + 3y^2 - x + 5y + 3 = 0$ is the empty set, but is being classified as an ellipse.

* $5x^2 + 4y^2 - 4x - 5y + 4 = 0$ is the empty set, but is being classified as an ellipse.

* $5y^2 - 4y + 2 = 0$ is a degenerate parabola which is the empty set, and is being correctly classified. So the problem appears to be ellipses only.

::: {.rmdnote latex=1}

Thing is, the algorithm does not consider these ellipses as degenerate.

:::


## Analysis

```{python}
A, C, D, E, F = symbols('A C D E F', real=True)
eq = A*x**2 + C*y**2 + D*x + E*y + F

eqx = complsq(A*x**2 + D*x, x)
eqy = complsq(C*y**2 + E*y, y)

eqsq = eqx + eqy + F

eqsq
```

```{python}
a2 = Wild('a2', exclude=[x, y])
b2 = Wild('b2', exclude=[x, y])
sq1 = Wild('sq1', exclude=[y])
sq2 = Wild('sq2', exclude=[x])
ind = Wild('ind', exclude=[x, y])

m = eqsq.match(a2 * sq1 + b2 * sq2 - ind)

eqcan = sq1 / (ind / a2) + sq2 / (ind / b2)
eqcan = eqcan.subs(m)
eqcan
```

This sum must equal $1$.

When is this impossible?

We know (because this is an ellipse) that $A$ and $C$ have the same sign.

So, either both terms in the sum above are positive or both are negative.

This is the empty set iff both are negative, i.e., iff

$$
A \cdot \left(`r m('{{ ind.subs(m) }}')`\right) < 0
$$

I must test for this in the ellipse case.


# Algorithm: find canonical equation

```{python}
def find_canonical_eq(conic):
  
  conic_type = conic['conic_type']
  
  if conic_type == 'parabola':
    do_parabola(conic)
  elif conic_type in ['ellipse', 'circle']:
    do_ellipse(conic)
    
```


## Parabola

### Nondegenerate

* I have an equation

  $$
  Ax^2 + Dx + Ey + F = 0
  $$

  or
  
  $$
  Cy^2 + Dx + Ey + F = 0
  $$


### Degenerate

#### Coincident lines

```{python}
A, C, D, E, F = symbols('A C D E F', real=True)
eq = A*x**2 + D*x + F
eq
```

All I have to do is to take the roots:

```{python}
solve(eq, x)
```

```{python}
A, C, D, E, F = symbols('A C D E F', real=True)
eq = C*y**2 + E*y + F
eq
```

All I have to do is to take the roots:

```{python}
solve(eq, y)
```


### Algorithm: do parabola
  
```{python}
def do_parabola(conic):
  
  A, C, D, E, F = [conic[c] for c in 'ACDEF']
  
  # x part
  eqx = A*x**2 + D*x
  
  # y part
  eqy = C*y**2 + E*y
  
  # Used to build the new equation
  a, b, c = [Wild(w, exclude=[x, y]) for w in 'abc']
  
  if C == 0: # This is a parabola with x^2
    
    # Build new equation
    if not conic['is_degenerate']:  # Nondegenerate case
      
      # Complete the square only for the x part
      eqx = complsq(eqx, x)
      
      # Get constants in the completed square
      m = eqx.match(a * (x + b)**2 + c)
          
      neweq = Eq(y + (F + c)/E, -a * (x + b)**2 / E).xreplace(m)
      conic['eq_canonical'] = [neweq]
      
    else: # Degenerate cases (except empty set)
      
      if conic['degenerate_form'] == 'coincident lines':
        conic['eq_canonical'] = [Eq(x, -D/(2*A))]
      elif conic['degenerate_form'] == 'parallel lines':
        conic['eq_canonical'] = [ \
          Eq(x, (-D + sqrt(D**2 - 4*A*F))/(2*A)), \
          Eq(x, (-D - sqrt(D**2 - 4*A*F))/(2*A)) \
        ]
      
  else: # This is a parabola with y^2
    
    # Build new equation
    if not conic['is_degenerate']: # Nondegenerate case
          
      # Complete the square only for the y part
      eqy = complsq(eqy, y)
      
      # Get constants in the completed square
      m = eqy.match(a * (y + b)**2 + c)
      
      neweq = Eq(x + (F + c)/D, -a * (y + b)**2 / D).xreplace(m)
      conic['eq_canonical'] = [neweq]
      
    else: # Degenerate cases (except empty set)
      
      if conic['degenerate_form'] == 'coincident lines':
        conic['eq_canonical'] = [Eq(y, -E/(2*C))]
      elif conic['degenerate_form'] == 'parallel lines':
        conic['eq_canonical'] = [ \
          Eq(y, (-E + sqrt(E**2 - 4*C*F))/(2*C)), \
          Eq(y, (-E - sqrt(E**2 - 4*C*F))/(2*C)) \
        ]
```


### Tests for parabola

#### Nondegenerate

```{python}
parabolas = [ \
  5*y**2-3*x+3*y-2, \
  2*x**2+2*x-3*y-1, \
  4*y**2-4*x-5*y+5, \
  4*x**2-3*x-5*y-3, \
  2*y**2-4*x+5, \
  4*x**2+2*x-4*y+1, \
  -y**2+4*x+4*y-4, \
  x**2-2*x-4*y+3, \
  2*x**2-2*x-4*y+2, \
  -2*y**2+2*x-3*y-4, \
  x**2-x-4*y-2, \
  3*y**2-2*x-2*y, \
  -y**2+x+5*y+1, \
  y + x**2, \
  x + y**2 \
]
```

```{python}
parabolas = [classify(eq) for eq in parabolas]

for conic in parabolas:
  find_canonical_eq(conic)
  
pp(parabolas)
```

```{r}
m(
  '{{ [ e["eq_canonical"] for e in parabolas ] }} \\\\',
  before = '$$\n\\displaystyle \\begin{array}{l}',
  after = '\\end{array}\n$$'
)
```

General, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_general"] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Canonical, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_canonical"][0] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```


#### Parallel lines

```{python}
parabolas = [ \
  3*x**2+4*x+1, \
  4*y**2+2*y-4, \
  -4*x**2+x, \
  x**2-2, \
  4*y**2-y-3, \
  -3*x**2-5*x+1, \
  -x**2-2*x+3, \
  -5*y**2+3*y, \
  -4*y**2+y+5, \
  4*x**2-5*x+1, \
  -5*y**2+4*y+4, \
  -3*y**2+2*y+1, \
  -2*y**2+2*y+1, \
  -x**2+2*x+1, \
  -x**2-2*x+1, \
  -3*x**2+4*x+4, \
  -5*y**2+2*y+1, \
  -5*y**2-2*y+1 \
]
```

```{python}
parabolas = [classify(eq) for eq in parabolas]

for conic in parabolas:
  find_canonical_eq(conic)
  
pp(parabolas)
```

```{r}
m(
  '{{ [ e["eq_canonical"] for e in parabolas ] }} \\\\',
  before = '$$\n\\displaystyle \\begin{array}{l}',
  after = '\\end{array}\n$$'
)
```

General, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_general"] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Canonical, to paste into Geogebra (one line):

```{r}
m(
  '{{r: [ e["eq_canonical"][0] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Canonical, to paste into Geogebra (other line):

```{r}
m(
  '{{r: [ e["eq_canonical"][1] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```


#### Coincident lines

```{python}
parabolas = [ \
  3*x**2, \
  x**2, \
  3*y**2, \
  y**2, \
  x**2 - 4*x + 4, \
  y**2 - 4*y + 4 \
]
```

```{python}
parabolas = [classify(eq) for eq in parabolas]

for conic in parabolas:
  find_canonical_eq(conic)
  
pp(parabolas)
```

```{r}
m(
  '{{ [ e["eq_canonical"][0] for e in parabolas ] }} \\\\',
  before = '$$\n\\displaystyle \\begin{array}{l}',
  after = '\\end{array}\n$$'
)
```

General, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_general"] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Canonical, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_canonical"] for e in parabolas ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```


#### Empty set

```{python}
parabolas = [ \
  5*y**2 - 4*y + 2, \
  5*x**2 - 4*x + 2, \
]
```

```{python}
parabolas = [classify(eq) for eq in parabolas]

for conic in parabolas:
  find_canonical_eq(conic)
  
pp(parabolas)
```


## Ellipse or circle

### Algorithm: do ellipse
  
```{python}
def do_ellipse(conic):
  
  A, C, D, E, F = [conic[c] for c in 'ACDEF']
  
  # x part
  eqx = A*x**2 + D*x
  
  # y part
  eqy = C*y**2 + E*y
  
  # Used to build the new equation 
  a, b, r = [Wild(w, exclude=[x, y]) for w in 'abr']
  qx = Wild('qx', exclude=[y])
  qy = Wild('qy', exclude=[x])
  
  # Build a(x - ...)^2 + b(y - ...)^2 = r
  neweq = complsq(eqx, x) + complsq(eqy, y) + F
  m = neweq.match(a * qx**2 + b * qy**2 + r)
  
  aa = a.xreplace(m)
  bb = b.xreplace(m)
  rr = r.xreplace(m)
  qqx = qx.xreplace(m)
  qqy = qy.xreplace(m)
  
  # Make sure lhs will be positive
  if aa < 0 and bb < 0:
    aa, bb, rr = -aa, -bb, -rr
  
  neweq = Eq( \
    aa * qqx**2 + bb * qqy**2, -rr, \
    # Must keep unevaluated, or empty sets will simplify to False:
    evaluate=False \
  )
  
  # If nondegenerate ellipse, make rhs 1
  # And push constants to denominators
  if conic['conic_type'] == 'ellipse' and -rr > 0:
    
    neweq = Eq(neweq.lhs / -rr, 1)
    
    mm = neweq.lhs.match(qx**2 / a + qy**2 / b)
    aa = a.xreplace(mm)
    bb = b.xreplace(mm)
    qqx = qx.xreplace(mm)
    qqy = qy.xreplace(mm)
    
    newlhs = sympify( \
      'qqx**2 / aa + qqy**2 / bb', \
      locals={'qqx': qqx, 'aa': aa, 'qqy': qqy, 'bb': bb}, \
      evaluate=False \
    )
    
    neweq = Eq(newlhs, 1)
    
  elif conic['conic_type'] == 'circle':
    # If circle, make aa = bb = 1
    neweq = Eq(neweq.lhs / aa, -rr / aa)
    
  # Store in dict
  conic['eq_canonical'] = [neweq]
  
  # If point, find coordinates and append to field in dict
  if conic['is_degenerate'] and conic['degenerate_form'] == 'point':
    p = (solve(qqx)[0], solve(qqy)[0])
    conic['eq_canonical'].append(p)
  
```


### Tests for do_ellipse

```{python}
eqs = [ \
  -5*x**2-3*y**2-4*x-2*y+4, \
  4*x**2+y**2+4*x+3*y+2, \
  -5*x**2-y**2-2*x+5*y+2, \
  2*x**2+3*y**2+5*x+3, \
  x**2+5*y**2+4*x-4*y+1, \
  5*x**2+4*y**2-x-3*y-2, \
  4*x**2+2*y**2-x+3*y-3, \
  x**2+5*y**2+4*x-5*y-1, \
  -4*x**2-2*y**2-4*x+5*y+5, \
  -4*x**2-5*y**2-2*x+3*y+1, \
  -5*x**2-5*y**2-4*x+2*y-1, \
  2*x**2+y**2-4*x+2, \
  -2*x**2-4*y**2-4*y-1, \
  -x**2-4*y**2+4*x-4*y-5, \
  4*x**2+y**2+2*y+1, \
  -x**2-2*y**2+2*x-1, \
  5*x**2+y**2+4*y+4, \
  -4*x**2-2*y**2, \
  -5*x**2-5*y**2-2*x-4*y-1, \
  -3*x**2-y**2-3*x+3*y-3, \
  4*x**2+5*y**2+2*x+y+3, \
  -5*x**2-4*y**2+5*x-y-2, \
  -4*x**2-4*y**2+x+4*y-2, \
  4*x**2+4*y**2-5*x-y+5, \
  -5*x**2-3*y**2+4*x-4*y-5, \
  -5*x**2-4*y**2+2*x-y-5, \
  -2*x**2-2*y**2+2*x-5*y-4, \
  5*x**2+3*y**2-x+5*y+3, \
  5*x**2+4*y**2-4*x-5*y+4 \
]
```

```{python}
ellipses = [classify(c) for c in eqs]
```

```{r}
py$ellipses %>% 
  map_chr(~pluck(., 'conic_type'))
```

```{python}
for e in ellipses:
  find_canonical_eq(e)
```

General, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_general"] for e in ellipses ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

Canonical, to paste into Geogebra:

```{r}
m(
  '{{r: [ e["eq_canonical"][0] for e in ellipses ] }}',
  sep_middle = ', ',
  before = '{',
  after = '}',
  sep_blocks = ' ',
  use_cat = TRUE  
) %>% 
  gsub('==', '=', ., fixed = TRUE) %>% 
  cat()
```

```{r}
m(
  '{{ [ e[\'eq_general\'] for e in ellipses ] }} & ',
  '\\displaystyle {{ [ e[\'eq_canonical\'] for e in ellipses ] }} & ',
  '\\text{ {{s:[ e[\'degenerate_form\'] for e in ellipses ] }} }\\\\ \n',
  before = '\\begin{array}{rll} \n',
  after = ' \\end{array}'
)
```

