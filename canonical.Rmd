---
title: 'Find canonical equation'
author: 'fnaufel'
email: 'https://fnaufel.github.io/'
date: '   (v. `r format(Sys.Date(), "%d/%m/%Y")`)'
lang: 'en'

output: 
  # To install these output formats, run
  #   install.packages("devtools")
  #   devtools::install_github("fnaufel/fnaufelRmd")
  fnaufelRmd::html_report:
    []
---

```{r setup, include=FALSE}
# The next command configures MANY things and loads quite a few packages.
# 
# If you want to see what's being done, execute 
# 
#   cat(
#     system.file(
#       "rmarkdown/resources/R/_common_report.R", 
#       package = "fnaufelRmd"
#     )
#   )
# 
# to find out the location of the file. Then open the file.
# 
# If you want to change the configuration, copy the file, edit it, and
# source it instead of the package file. 
# 
# Or simply write your commands here in this code chunk.

source(
  system.file(
    "rmarkdown/resources/R/_common_report.R",
    package = "fnaufelRmd"
  )
)

library(reticulate)
library(sympyglue)

sympy = import('sympy')
py_run_string('from sympy import *')
py_run_string('init_printing(use_latex=True)')
py_run_string('from pprint import pp')
py_run_string('x, y = symbols(\'x y\')')
```


# Classify using match

```{python}
def classify(eq):
  
  error_msg = '''
  Equation must be of the form Ax^2 + Cy^2 + Dx + Ey + F
  The input was ''' + latex(eq)
    
  a, b, c, d, e, f = [ \
    Wild(w, exclude=[x, y]) for w in 'abcdef' \
  ]
  
  m = eq.match(a*x**2 + b*x*y + c*y**2 + d*x + e*y + f)

  if m is None:
    raise ValueError(error_msg)
  
  A = m[Wild('a', exclude=[x,y])]
  B = m[Wild('b', exclude=[x,y])]
  C = m[Wild('c', exclude=[x,y])]
  D = m[Wild('d', exclude=[x,y])]
  E = m[Wild('e', exclude=[x,y])]
  F = m[Wild('f', exclude=[x,y])]
  
  if B != 0 or (A == 0 and C == 0):
    raise ValueError(error_msg)
  
  retval = { \
    'eq': eq, \
    'A': A, \
    'B': B, \
    'C': C, \
    'D': D, \
    'E': E, \
    'F': F \
  }

  if A * C > 0:
    lmbda = D**2 / (4 * A) + E**2 / (4 * C) - F
    if A * lmbda > 0:
      if A == C:
        conic_type = 'circle'
      else:
        conic_type = 'ellipse'
    elif lmbda == 0:
      conic_type = 'point'
    else:
      conic_type = 'empty set'
  
  if A * C < 0:
    lmbda = D**2 / (4 * A) + E**2 / (4 * C) - F
    if A * lmbda != 0:
      conic_type = 'hyperbola'
    elif lmbda == 0:
      conic_type = 'concurrent lines'
  
  if A != 0 and C == 0:
    if A * E < 0:
      conic_type = 'parabola'
    elif A * E > 0:
      conic_type = 'empty set'
    else:
      mu1 = D**2 / (4 * A) - F
      if A * mu1 >= 0:
        if 4 * F == D**2:
          conic_type = 'one line'
        else:
          conic_type = 'parallel lines'
      else:
        conic_type = 'empty set'
  
  if A == 0 and C != 0:
    if C * D < 0:
      conic_type = 'parabola'
    elif C * D > 0:
      conic_type = 'empty set'
    else:
      mu2 = D**2 / (4 * C) - F
      if C * mu2 >= 0:
        if 4 * F == E**2:
          conic_type = 'one line'
        else:
          conic_type = 'parallel lines'
      else:
        conic_type = 'empty set'
  
  retval['conic_type'] = conic_type
  
  return retval
```


## Tests for classify

```{python}
eq = x**2 + 2*x + y**2 + 4*y - 4
pp(classify(eq))
```

```{python error=TRUE}
eq = x + y
pp(classify(eq))
```

```{python}
eq = x**2 + x + 1
pp(classify(eq))
```

```{python error=TRUE}
eq = x * y
classify(eq)
```

```{python error=TRUE}
eq = x**2 + x*y + y**2 + x + y + 1
classify(eq)
```


```{python}
eqs = [ \
  2*x**2+y**2-4*x+5*y-1, \
  x**2+2*y**2-5*x-5*y+1, \
  -4*x**2-2*y**2-5*x+y+1, \
  -x**2-y**2-4*x+y+5, \
  -3*x**2-5*y**2+3*x-2*y, \
  5*x**2+5*y**2-5*y, \
  -x**2-2*y**2+4*x+2*y+5, \
  -2*x**2-5*y**2+y+4, \
  -x**2-y**2-4*x-3*y+4, \
  -2*x**2-4*y**2+3*x+3*y+1, \
  -5*x**2-y**2-x-4*y+2, \
  -5*x**2-2*y**2+4*x+4*y-1, \
  -4*x**2-5*y**2-2*x+2*y+2, \
  -4*x**2+y**2-4*x+5*y+4, \
  -2*x**2+2*y**2+5*x-4*y+2, \
  5*x**2-2*y**2+4*x-4*y, \
  -3*x**2+y**2-2*x+4*y+3, \
  -3*x**2+2*y**2-3*x-3*y-3, \
  -5*x**2+3*y**2+3*x+3*y-4, \
  -5*x**2+3*y**2-x+2*y-5, \
  -4*x**2+5*y**2+x-y-1, \
  5*x**2-3*y**2-5*x+4*y+2, \
  5*x**2-y**2+3*x+5*y-2, \
  -x**2+2*y**2-5*x-2*y-2, \
  4*x**2-4*y**2-x-y+1, \
  2*x**2-2*y**2+3*x+2, \
  5*y**2-3*x+3*y-2, \
  2*x**2+2*x-3*y-1, \
  4*y**2-4*x-5*y+5, \
  4*x**2-3*x-5*y-3, \
  2*y**2-4*x+5, \
  4*x**2+2*x-4*y+1, \
  -y**2+4*x+4*y-4, \
  x**2-2*x-4*y+3, \
  2*x**2-2*x-4*y+2, \
  -2*y**2+2*x-3*y-4, \
  x**2-x-4*y-2, \
  3*y**2-2*x-2*y, \
  -y**2+x+5*y+1, \
  -y**2-3*y+3, \
  -5*x**2+2*x+4, \
  2*y**2+y-1, \
  y**2+y-1, \
  x**2+4*x-1, \
  x**2+5*x+5, \
  4*y**2+y-5, \
  3*y**2-5*y-1, \
  3*x**2-5*x-5, \
  2*x**2+2*x-3, \
  x**2-4*x-4, \
  5*y**2+2*y, \
  -3*x**2-4*x, \
  -4*y**2+1, \
  5*y**2+5*y, \
  3*x**2-4*x-3, \
  4*x**2+5*x, \
  -3*y**2-y+5, \
  -x**2+5*x-3, \
  4*x**2-5*y**2+2*x+5*y-1, \
  -5*x**2+5*y**2+3*x-3*y, \
  5*x**2-5*y**2+3*x+3*y, \
  -5*x**2+5*y**2-5*x-5*y, \
  5*x**2-y**2+5*x+3*y-1, \
  4*x**2-3*y**2, \
  -4*x**2+5*y**2+2*x-5*y+1, \
  -4*x**2+4*y**2-3*x+3*y, \
  2*x**2-2*y**2-5*x-5*y, \
  x**2-y**2-2*x-2*y, \
  -x**2+4*y**2+3*x+2*y-2, \
  -3*x**2+3*y**2-4*x-2*y-1, \
  4*x**2-y**2+4*x+4*y-3, \
  x**2-y**2-2*x+1, \
  4*x**2-4*y**2-x-y, \
  -3*x**2+2*y**2+4*y+2, \
  -x**2+y**2-4*x+2*y-3, \
  2*x**2-2*y**2-3*x-5*y-2 \
]
```

```{python}
eq_list = [classify(eq) for eq in eqs]
```

```{r}
m(
  '{{ [ e[\'eq\'] for e in eq_list ] }} &',
  '{{ [ e[\'conic_type\'] for e in eq_list ] }} \\\\',
  before = '$$\n\\begin{array}{rl}',
  after = '\\end{array}\n$$'
)
```


# Complete the square using match (TODO)

```{python}
def complsq(e, var):
  
  coefficients = e.as_poly(var).all_coeffs()
  
  if len(coefficients) != 3:
    raise ValueError('Expression must be of degree 2 in ' + str(var))
    
  a, b, c = coefficients
  
  second = Rational(b, 2*a)
  third = Rational(4*a*c - b**2, 4*a)
  
  return a * (var + second)**2 + third
```


# Find canonical equation (TODO)

```{python}
def find_canonical_eq(conic):
  
  A = conic['A']
  C = conic['C']
  D = conic['D']
  E = conic['E']
  F = conic['F']
  
  retval = None
  
  if conic['conic_type'] == 'parabola':
    retval = do_parabola(A, C, D, E, F)
    
  return retval
```


## Parabola (TODO)

* I have an equation

  $$
  Ax^2 + Dx + Ey + F = 0
  $$

  or
  
  $$
  Cy^2 + Dx + Ey + F = 0
  $$
  
```{python}
def do_parabola(A, C, D, E, F):
  
  eqx = A*x**2 + D*x
  eqy = C*y**2 + E*y
  a = Wild('a', exclude=[x, y])
  b = Wild('b', exclude=[x, y])
  c = Wild('c', exclude=[x, y])
  
  if C == 0:
    eqx = complsq(eqx, x)
    m = eqx.match(a * (x + b)**2 + c)
    neweq = Eq(y + (F + c)/E, -a * (x + b)**2 / E).xreplace(m)
  
  return neweq
```


### Tests for parabola

```{python}
parabolas = [ \
  # 5*y**2-3*x+3*y-2, \
  2*x**2+2*x-3*y-1, \
  # 4*y**2-4*x-5*y+5, \
  4*x**2-3*x-5*y-3, \
  # 2*y**2-4*x+5, \
  4*x**2+2*x-4*y+1, \
  # -y**2+4*x+4*y-4, \
  x**2-2*x-4*y+3, \
  2*x**2-2*x-4*y+2, \
  # -2*y**2+2*x-3*y-4, \
  x**2-x-4*y-2, \
  # 3*y**2-2*x-2*y, \
  # -y**2+x+5*y+1, \
]
```

```{python}
canonics = [find_canonical_eq(classify(eq)) for eq in parabolas]
```

```{r}
m(
  '{{ [ e for e in canonics ] }} \\\\',
  before = '$$\n\\displaystyle \\begin{array}{l}',
  after = '\\end{array}\n$$'
)
```


