---
title: 'Find canonical equation'
author: 'fnaufel'
email: 'https://fnaufel.github.io/'
date: '   (v. `r format(Sys.Date(), "%d/%m/%Y")`)'
lang: 'en'

output: 
  # To install these output formats, run
  #   install.packages("devtools")
  #   devtools::install_github("fnaufel/fnaufelRmd")
  fnaufelRmd::html_report:
    []
---

```{r setup, include=FALSE}
# The next command configures MANY things and loads quite a few packages.
# 
# If you want to see what's being done, execute 
# 
#   cat(
#     system.file(
#       "rmarkdown/resources/R/_common_report.R", 
#       package = "fnaufelRmd"
#     )
#   )
# 
# to find out the location of the file. Then open the file.
# 
# If you want to change the configuration, copy the file, edit it, and
# source it instead of the package file. 
# 
# Or simply write your commands here in this code chunk.

source(
  system.file(
    "rmarkdown/resources/R/_common_report.R",
    package = "fnaufelRmd"
  )
)

library(reticulate)
library(sympyglue)

sympy = import('sympy')
py_run_string('from sympy import *')
py_run_string('init_printing(use_latex=True)')
py_run_string('from pprint import pp')
py_run_string('x, y = symbols(\'x y\')')
```


# Classify using match

```{python}
def classify(eq):
  
  error_msg = '''
  Equation must be of the form Ax^2 + Cy^2 + Dx + Ey + F.
  The input was ''' + latex(eq)
  
  # Used to match the coefficients of the equation
  a, b, c, d, e, f = [ \
    Wild(w, exclude=[x, y]) for w in 'abcdef' \
  ]
  
  # Match
  m = eq.match(a*x**2 + b*x*y + c*y**2 + d*x + e*y + f)
  
  # No match: bad equation
  if m is None:
    raise ValueError(error_msg)
  
  # Get coefficients
  A, B, C, D, E, F = [w.xreplace(m) for w in [a, b, c, d, e, f]]
  
  # Must be degree 2 in at least one of the vars
  # No rotated conics for now
  if B != 0 or (A == 0 and C == 0):
    raise ValueError(error_msg)
  
  # Collect everything in a dict
  retval = { \
    'eq_general': eq, \
    'A': A, \
    'B': B, \
    'C': C, \
    'D': D, \
    'E': E, \
    'F': F \
  }
  
  # Find out type of conic
  if A * C > 0:
    lmbda = D**2 / (4 * A) + E**2 / (4 * C) - F
    if A * lmbda > 0:
      if A == C:
        conic_type = 'circle'
      else:
        conic_type = 'ellipse'
    elif lmbda == 0:
      conic_type = 'point'
    else:
      conic_type = 'empty set'
  
  if A * C < 0:
    lmbda = D**2 / (4 * A) + E**2 / (4 * C) - F
    if A * lmbda != 0:
      conic_type = 'hyperbola'
    elif lmbda == 0:
      conic_type = 'concurrent lines'
  
  if A != 0 and C == 0:
    if A * E < 0:
      conic_type = 'parabola'
    elif A * E > 0:
      conic_type = 'empty set'
    else:
      mu1 = D**2 / (4 * A) - F
      if A * mu1 >= 0:
        if 4 * F == D**2:
          conic_type = 'one line'
        else:
          conic_type = 'parallel lines'
      else:
        conic_type = 'empty set'
  
  if A == 0 and C != 0:
    if C * D < 0:
      conic_type = 'parabola'
    elif C * D > 0:
      conic_type = 'empty set'
    else:
      mu2 = D**2 / (4 * C) - F
      if C * mu2 >= 0:
        if 4 * F == E**2:
          conic_type = 'one line'
        else:
          conic_type = 'parallel lines'
      else:
        conic_type = 'empty set'
  
  # Save type in dict
  retval['conic_type'] = conic_type
  
  return retval
```


## Tests for classify

```{python}
eq = x**2 + 2*x + y**2 + 4*y - 4
pp(classify(eq))
```

```{python error=TRUE}
eq = x + y
pp(classify(eq))
```

```{python}
eq = x**2 + x + 1
pp(classify(eq))
```

```{python error=TRUE}
eq = x * y
classify(eq)
```

```{python error=TRUE}
eq = x**2 + x*y + y**2 + x + y + 1
classify(eq)
```


```{python}
eqs = [ \
  2*x**2+y**2-4*x+5*y-1, \
  x**2+2*y**2-5*x-5*y+1, \
  -4*x**2-2*y**2-5*x+y+1, \
  -x**2-y**2-4*x+y+5, \
  -3*x**2-5*y**2+3*x-2*y, \
  5*x**2+5*y**2-5*y, \
  -x**2-2*y**2+4*x+2*y+5, \
  -2*x**2-5*y**2+y+4, \
  -x**2-y**2-4*x-3*y+4, \
  -2*x**2-4*y**2+3*x+3*y+1, \
  -5*x**2-y**2-x-4*y+2, \
  -5*x**2-2*y**2+4*x+4*y-1, \
  -4*x**2-5*y**2-2*x+2*y+2, \
  -4*x**2+y**2-4*x+5*y+4, \
  -2*x**2+2*y**2+5*x-4*y+2, \
  5*x**2-2*y**2+4*x-4*y, \
  -3*x**2+y**2-2*x+4*y+3, \
  -3*x**2+2*y**2-3*x-3*y-3, \
  -5*x**2+3*y**2+3*x+3*y-4, \
  -5*x**2+3*y**2-x+2*y-5, \
  -4*x**2+5*y**2+x-y-1, \
  5*x**2-3*y**2-5*x+4*y+2, \
  5*x**2-y**2+3*x+5*y-2, \
  -x**2+2*y**2-5*x-2*y-2, \
  4*x**2-4*y**2-x-y+1, \
  2*x**2-2*y**2+3*x+2, \
  5*y**2-3*x+3*y-2, \
  2*x**2+2*x-3*y-1, \
  4*y**2-4*x-5*y+5, \
  4*x**2-3*x-5*y-3, \
  2*y**2-4*x+5, \
  4*x**2+2*x-4*y+1, \
  -y**2+4*x+4*y-4, \
  x**2-2*x-4*y+3, \
  2*x**2-2*x-4*y+2, \
  -2*y**2+2*x-3*y-4, \
  x**2-x-4*y-2, \
  3*y**2-2*x-2*y, \
  -y**2+x+5*y+1, \
  -y**2-3*y+3, \
  -5*x**2+2*x+4, \
  2*y**2+y-1, \
  y**2+y-1, \
  x**2+4*x-1, \
  x**2+5*x+5, \
  4*y**2+y-5, \
  3*y**2-5*y-1, \
  3*x**2-5*x-5, \
  2*x**2+2*x-3, \
  x**2-4*x-4, \
  5*y**2+2*y, \
  -3*x**2-4*x, \
  -4*y**2+1, \
  5*y**2+5*y, \
  3*x**2-4*x-3, \
  4*x**2+5*x, \
  -3*y**2-y+5, \
  -x**2+5*x-3, \
  4*x**2-5*y**2+2*x+5*y-1, \
  -5*x**2+5*y**2+3*x-3*y, \
  5*x**2-5*y**2+3*x+3*y, \
  -5*x**2+5*y**2-5*x-5*y, \
  5*x**2-y**2+5*x+3*y-1, \
  4*x**2-3*y**2, \
  -4*x**2+5*y**2+2*x-5*y+1, \
  -4*x**2+4*y**2-3*x+3*y, \
  2*x**2-2*y**2-5*x-5*y, \
  x**2-y**2-2*x-2*y, \
  -x**2+4*y**2+3*x+2*y-2, \
  -3*x**2+3*y**2-4*x-2*y-1, \
  4*x**2-y**2+4*x+4*y-3, \
  x**2-y**2-2*x+1, \
  4*x**2-4*y**2-x-y, \
  -3*x**2+2*y**2+4*y+2, \
  -x**2+y**2-4*x+2*y-3, \
  2*x**2-2*y**2-3*x-5*y-2 \
]
```

```{python}
eq_list = [classify(eq) for eq in eqs]
```

```{r}
m(
  '{{ [ e[\'eq_general\'] for e in eq_list ] }} &',
  '{{ [ e[\'conic_type\'] for e in eq_list ] }} \\\\',
  before = '$$\n\\begin{array}{rl}',
  after = '\\end{array}\n$$'
)
```


# Complete the square using match

```{python}
def complsq(expr, var):
  
  # e is of the form ax^2 + bx + c, and var == x
  
  error_msg = '''
  Expression must be of the form ax^2 + bx + c.
  The input was ''' + latex(expr)
  
  # var may be any symbol, but let's call it x here
  x = var
  
  # Used to match the coefficients
  a, b, c = [ \
    Wild(w, exclude=[x, y]) for w in 'abc' \
  ]
  
  # Match
  m = expr.match(a*x**2 + b*x + c)
  
  # No match: bad expression
  if m is None:
    raise ValueError(error_msg)
  
  # Get coefficients
  A, B, C = [w.xreplace(m) for w in [a, b, c]]
  
  # Expression must be of degree 2
  if A == 0:
    raise ValueError(error_msg)
  
  # Will return A (x + B/2A)^2 + (4AC - B^2)/4A
  second = Rational(B, 2*A)
  third = Rational(4*A*C - B**2, 4*A)
  
  return A * (var + second)**2 + third
```


## Test complete square

```{python error=TRUE}
complsq(x**4 + 2*x, x)
```

```{r}
eg <- function(e) {
  
  cmd <- paste0('e = ', rlang::expr_text(rlang::enexpr(e)))
  cmd <- gsub('^', '**', cmd, fixed = TRUE)
  py_run_string(cmd)
  
  m('$$\\displaystyle {{e}} \\quad=\\quad {{complsq(e, x)}}$$')
}
```

```{r}
eg(x**2 + 2*x)
```

```{r}
eg(x**2 + 2*x + 1)
```

```{r}
eg(x**2 - 2*x)
```

```{r}
eg(4*x**2 + 2*x)
```

```{r}
eg(4*x**2 - 2*x)
```

```{r}
eg(-4*x**2 + 2*x)
```

```{r}
eg(-4*x**2 - 2*x)
```

```{r}
eg(4*x**2 + 2*x + 10)
```


# Find canonical equation (TODO)

```{python}
def find_canonical_eq(conic):
  
  A = conic['A']
  C = conic['C']
  D = conic['D']
  E = conic['E']
  F = conic['F']
  
  retval = None
  
  if conic['conic_type'] == 'parabola':
    retval = do_parabola(A, C, D, E, F)
    
  return retval
```


## Parabola (TODO)

* I have an equation

  $$
  Ax^2 + Dx + Ey + F = 0
  $$

  or
  
  $$
  Cy^2 + Dx + Ey + F = 0
  $$
  
```{python}
def do_parabola(A, C, D, E, F):
  
  eqx = A*x**2 + D*x
  eqy = C*y**2 + E*y
  a = Wild('a', exclude=[x, y])
  b = Wild('b', exclude=[x, y])
  c = Wild('c', exclude=[x, y])
  
  if C == 0:
    eqx = complsq(eqx, x)
    m = eqx.match(a * (x + b)**2 + c)
    neweq = Eq(y + (F + c)/E, -a * (x + b)**2 / E).xreplace(m)
  
  return neweq
```


### Tests for parabola

```{python}
parabolas = [ \
  # 5*y**2-3*x+3*y-2, \
  2*x**2+2*x-3*y-1, \
  # 4*y**2-4*x-5*y+5, \
  4*x**2-3*x-5*y-3, \
  # 2*y**2-4*x+5, \
  4*x**2+2*x-4*y+1, \
  # -y**2+4*x+4*y-4, \
  x**2-2*x-4*y+3, \
  2*x**2-2*x-4*y+2, \
  # -2*y**2+2*x-3*y-4, \
  x**2-x-4*y-2, \
  # 3*y**2-2*x-2*y, \
  # -y**2+x+5*y+1, \
]
```

```{python}
canonics = [find_canonical_eq(classify(eq)) for eq in parabolas]
```

```{r}
m(
  '{{ [ e for e in canonics ] }} \\\\',
  before = '$$\n\\displaystyle \\begin{array}{l}',
  after = '\\end{array}\n$$'
)
```


